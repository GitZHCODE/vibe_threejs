<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Twisting Hexagonal Towers</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background-color: #1a1a1a;
            color: #ffffff;
            overflow-x: hidden;
        }
        #controls {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            padding: 20px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            width: 280px;
            max-height: 90vh;
            overflow-y: auto;
            scrollbar-width: thin;
            scrollbar-color: #444 #222;
        }
        #controls::-webkit-scrollbar {
            width: 8px;
        }
        #controls::-webkit-scrollbar-track {
            background: #222;
        }
        #controls::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 4px;
        }
        .control-group {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #333;
        }
        .control-group:last-child {
            border-bottom: none;
        }
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #aaa;
        }
        input[type="range"] {
            width: 100%;
            margin-bottom: 5px;
        }
        input[type="color"] {
            width: 100%;
            height: 30px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        select {
            width: 100%;
            padding: 5px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            margin-bottom: 5px;
        }
        .value {
            font-size: 11px;
            color: #888;
            text-align: right;
        }
        h3 {
            margin-top: 0;
            margin-bottom: 15px;
            color: #fff;
            font-size: 16px;
        }
        h4 {
            margin: 15px 0 10px 0;
            color: #ccc;
            font-size: 14px;
        }
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .checkbox-group input {
            margin-right: 8px;
        }
    </style>
</head>
<body>
    <div id="controls">
        <h3>Advanced Tower Controls</h3>
        
        <h4>Basic Parameters</h4>
        <div class="control-group">
            <label>Truncation Position</label>
            <input type="range" id="truncation" min="0.1" max="0.9" value="0.5" step="0.05">
            <div class="value" id="truncationValue">0.5</div>
        </div>
        <div class="control-group">
            <label>Layer Spacing</label>
            <input type="range" id="spacing" min="2" max="20" value="8" step="1">
            <div class="value" id="spacingValue">8</div>
        </div>
        <div class="control-group">
            <label>Twist Amount (degrees)</label>
            <input type="range" id="twist" min="0" max="180" value="60" step="5">
            <div class="value" id="twistValue">60°</div>
        </div>
        <div class="control-group">
            <label>Tower Height</label>
            <input type="range" id="layers" min="10" max="50" value="30" step="1">
            <div class="value" id="layersValue">30 layers</div>
        </div>
        <div class="control-group">
            <label>Base Size</label>
            <input type="range" id="baseSize" min="20" max="100" value="50" step="5">
            <div class="value" id="baseSizeValue">50</div>
        </div>

        <h4>Scaling Attractor</h4>
        <div class="control-group">
            <label>Attractor Type</label>
            <select id="attractorType">
                <option value="linear">Linear</option>
                <option value="exponential">Exponential</option>
                <option value="sine">Sine Wave</option>
                <option value="parabolic">Parabolic</option>
            </select>
        </div>
        <div class="control-group">
            <label>Attractor Location (Height %)</label>
            <input type="range" id="attractorLocation" min="0" max="100" value="50" step="5">
            <div class="value" id="attractorLocationValue">50%</div>
        </div>
        <div class="control-group">
            <label>Attractor Decay</label>
            <input type="range" id="attractorDecay" min="0.1" max="5" value="1" step="0.1">
            <div class="value" id="attractorDecayValue">1.0</div>
        </div>
        <div class="control-group">
            <label>Minimum Scale</label>
            <input type="range" id="minScale" min="0.1" max="0.9" value="0.4" step="0.05">
            <div class="value" id="minScaleValue">0.4</div>
        </div>

        <h4>Colors</h4>
        <div class="control-group">
            <label>Slab Color</label>
            <input type="color" id="slabColor" value="#4a90e2">
        </div>
        <div class="control-group">
            <label>Base Color</label>
            <input type="color" id="baseColor" value="#2c3e50">
        </div>
        <div class="control-group">
            <label>Sky Color</label>
            <input type="color" id="skyColor" value="#1a2634">
        </div>

        <h4>Balustrade</h4>
        <div class="control-group">
            <div class="checkbox-group">
                <input type="checkbox" id="balustradeVisible" checked>
                <label for="balustradeVisible" style="margin-bottom: 0;">Balustrade Visible</label>
            </div>
        </div>
        <div class="control-group">
            <label>Balustrade Mode</label>
            <select id="balustradeMode">
                <option value="solid">Solid</option>
                <option value="posts">Posts</option>
                <option value="diagonal">Diagonal Pattern</option>
                <option value="mesh">Mesh</option>
            </select>
        </div>
        <div class="control-group">
            <label>Balustrade Extrusion</label>
            <input type="range" id="balustradeExtrusion" min="0" max="20" value="5" step="1">
            <div class="value" id="balustradeExtrusionValue">5 units</div>
        </div>
        <div class="control-group">
            <label>Balustrade Opacity</label>
            <input type="range" id="balustradeOpacity" min="0" max="255" value="180" step="5">
            <div class="value" id="balustradeOpacityValue">180</div>
        </div>

        <h4>Base Texture</h4>
        <div class="control-group">
            <label>Base Texture Type</label>
            <select id="baseTexture">
                <option value="smooth">Smooth</option>
                <option value="grid">Grid</option>
                <option value="radial">Radial</option>
                <option value="noise">Noise</option>
            </select>
        </div>
    </div>
    
    <script>
        // Basic parameters
        let truncation = 0.5;
        let spacing = 8;
        let twistAmount = 60;
        let numLayers = 30;
        let baseSize = 50;
        let rotation = 0;

        // Attractor parameters
        let attractorType = 'linear';
        let attractorLocation = 0.5;
        let attractorDecay = 1;
        let minScale = 0.4;

        // Colors
        let slabColor, baseColor, skyColor;
        
        // Balustrade parameters
        let balustradeVisible = true;
        let balustradeMode = 'solid';
        let balustradeExtrusion = 5;
        let balustradeOpacity = 180;

        // Base texture
        let baseTexture = 'smooth';

        function setup() {
            createCanvas(windowWidth, windowHeight, WEBGL);
            colorMode(RGB);
            
            // Initialize colors
            slabColor = color('#4a90e2');
            baseColor = color('#2c3e50');
            skyColor = color('#1a2634');
            
            setupControls();
        }

        function setupControls() {
            // Basic controls
            document.getElementById('truncation').addEventListener('input', (e) => {
                truncation = parseFloat(e.target.value);
                document.getElementById('truncationValue').textContent = truncation.toFixed(2);
            });

            document.getElementById('spacing').addEventListener('input', (e) => {
                spacing = parseInt(e.target.value);
                document.getElementById('spacingValue').textContent = spacing;
            });

            document.getElementById('twist').addEventListener('input', (e) => {
                twistAmount = parseInt(e.target.value);
                document.getElementById('twistValue').textContent = twistAmount + '°';
            });

            document.getElementById('layers').addEventListener('input', (e) => {
                numLayers = parseInt(e.target.value);
                document.getElementById('layersValue').textContent = numLayers + ' layers';
            });

            document.getElementById('baseSize').addEventListener('input', (e) => {
                baseSize = parseInt(e.target.value);
                document.getElementById('baseSizeValue').textContent = baseSize;
            });

            // Attractor controls
            document.getElementById('attractorType').addEventListener('change', (e) => {
                attractorType = e.target.value;
            });

            document.getElementById('attractorLocation').addEventListener('input', (e) => {
                attractorLocation = parseInt(e.target.value) / 100;
                document.getElementById('attractorLocationValue').textContent = e.target.value + '%';
            });

            document.getElementById('attractorDecay').addEventListener('input', (e) => {
                attractorDecay = parseFloat(e.target.value);
                document.getElementById('attractorDecayValue').textContent = attractorDecay.toFixed(1);
            });

            document.getElementById('minScale').addEventListener('input', (e) => {
                minScale = parseFloat(e.target.value);
                document.getElementById('minScaleValue').textContent = minScale.toFixed(2);
            });

            // Color controls
            document.getElementById('slabColor').addEventListener('input', (e) => {
                slabColor = color(e.target.value);
            });

            document.getElementById('baseColor').addEventListener('input', (e) => {
                baseColor = color(e.target.value);
            });

            document.getElementById('skyColor').addEventListener('input', (e) => {
                skyColor = color(e.target.value);
            });

            // Balustrade controls
            document.getElementById('balustradeVisible').addEventListener('change', (e) => {
                balustradeVisible = e.target.checked;
            });

            document.getElementById('balustradeMode').addEventListener('change', (e) => {
                balustradeMode = e.target.value;
            });

            document.getElementById('balustradeExtrusion').addEventListener('input', (e) => {
                balustradeExtrusion = parseInt(e.target.value);
                document.getElementById('balustradeExtrusionValue').textContent = e.target.value + ' units';
            });

            document.getElementById('balustradeOpacity').addEventListener('input', (e) => {
                balustradeOpacity = parseInt(e.target.value);
                document.getElementById('balustradeOpacityValue').textContent = balustradeOpacity;
            });

            // Base texture control
            document.getElementById('baseTexture').addEventListener('change', (e) => {
                baseTexture = e.target.value;
            });
        }

        function calculateAttractorScale(layerProgress) {
            let distance = abs(layerProgress - attractorLocation);
            let influence = 0;
            
            switch(attractorType) {
                case 'linear':
                    influence = max(0, 1 - distance * attractorDecay);
                    break;
                case 'exponential':
                    influence = exp(-distance * attractorDecay * 3);
                    break;
                case 'sine':
                    influence = sin(layerProgress * PI) * (1 - distance * attractorDecay);
                    break;
                case 'parabolic':
                    influence = max(0, 1 - pow(distance * attractorDecay, 2));
                    break;
            }
            
            return lerp(minScale, 1, influence);
        }

        function draw() {
            background(red(skyColor), green(skyColor), blue(skyColor));
            
            // Lighting
            ambientLight(50);
            directionalLight(255, 255, 255, 0.5, 0.5, -1);
            directionalLight(200, 200, 220, -0.5, -0.5, -1);
            
            // Camera rotation
            rotation += 0.003;
            let camX = sin(rotation) * 400;
            let camZ = cos(rotation) * 400;
            camera(camX, -200, camZ, 0, -100, 0, 0, 1, 0);
            
            // Draw ground plinth with texture
            drawBasePlinth();
            
            // Draw three towers
            let positions = [
                { x: -150, z: 0 },
                { x: 150, z: 0 },
                { x: 0, z: -130 }
            ];
            
            for (let t = 0; t < 3; t++) {
                push();
                translate(positions[t].x, -30, positions[t].z);
                drawTower(t);
                pop();
            }
        }

        function drawBasePlinth() {
            push();
            translate(0, 0, 0);
            noStroke();
            
            // Apply base texture
            if (baseTexture === 'grid') {
                // Grid texture
                for (let x = -250; x <= 250; x += 25) {
                    for (let z = -250; z <= 250; z += 25) {
                        push();
                        translate(x, 0, z);
                        let shade = noise(x * 0.01, z * 0.01) * 50;
                        fill(red(baseColor) + shade, green(baseColor) + shade, blue(baseColor) + shade);
                        box(24, 20, 24);
                        pop();
                    }
                }
            } else if (baseTexture === 'radial') {
                // Radial texture
                for (let r = 0; r < 10; r++) {
                    push();
                    let size = 500 - r * 40;
                    let bright = r * 10;
                    fill(red(baseColor) + bright, green(baseColor) + bright, blue(baseColor) + bright);
                    translate(0, -r * 2, 0);
                    box(size, 4, size);
                    pop();
                }
            } else if (baseTexture === 'noise') {
                // Noise texture
                for (let i = 0; i < 20; i++) {
                    push();
                    let x = random(-200, 200);
                    let z = random(-200, 200);
                    let size = random(20, 60);
                    translate(x, -random(0, 10), z);
                    fill(red(baseColor), green(baseColor), blue(baseColor), random(100, 255));
                    box(size, random(10, 30), size);
                    pop();
                }
            } else {
                // Smooth texture
                fill(red(baseColor), green(baseColor), blue(baseColor));
                box(500, 20, 500);
            }
            
            // Plinth gradient layers
            for (let i = 1; i < 5; i++) {
                let c = lerpColor(baseColor, color(100, 100, 100), i * 0.1);
                fill(red(c), green(c), blue(c));
                translate(0, -5, 0);
                box(500 - i * 40, 5, 500 - i * 40);
            }
            pop();
        }

        function drawTower(towerIndex) {
            for (let layer = 0; layer < numLayers; layer++) {
                let y = -layer * spacing;
                let layerProgress = layer / numLayers;
                
                // Calculate size with attractor influence
                let attractorScale = calculateAttractorScale(layerProgress);
                let size = baseSize * attractorScale;
                
                // Calculate twist
                let angle = (twistAmount * layerProgress * PI) / 180;
                
                push();
                translate(0, y, 0);
                rotateY(angle);
                
                // Draw hexagonal slab
                drawHexagon(size, truncation);
                
                // Draw balustrade if visible
                if (balustradeVisible && layer < numLayers - 1) {
                    drawBalustrade(size, layer, towerIndex);
                }
                
                pop();
            }
        }

        function drawHexagon(size, truncationFactor) {
            noStroke();
            fill(red(slabColor), green(slabColor), blue(slabColor));
            
            beginShape();
            for (let i = 0; i < 6; i++) {
                let angle1 = (TWO_PI / 6) * i;
                let angle2 = (TWO_PI / 6) * (i + 1);
                
                let x1 = cos(angle1) * size;
                let z1 = sin(angle1) * size;
                let x2 = cos(angle2) * size;
                let z2 = sin(angle2) * size;
                
                // Apply truncation
                let midAngle = (angle1 + angle2) / 2;
                let midX = cos(midAngle) * size * truncationFactor;
                let midZ = sin(midAngle) * size * truncationFactor;
                
                vertex(x1, 0, z1);
                vertex(midX, 0, midZ);
                vertex(x2, 0, z2);
            }
            endShape(CLOSE);
            
            // Add depth
            push();
            translate(0, -2, 0);
            fill(red(slabColor) * 0.8, green(slabColor) * 0.8, blue(slabColor) * 0.8);
            beginShape();
            for (let i = 0; i < 6; i++) {
                let angle = (TWO_PI / 6) * i;
                let x = cos(angle) * size;
                let z = sin(angle) * size;
                vertex(x, 0, z);
            }
            endShape(CLOSE);
            pop();
        }

        function drawBalustrade(size, layer, towerIndex) {
            push();
            fill(255, 255, 255, balustradeOpacity);
            stroke(255, 255, 255, balustradeOpacity * 0.5);
            strokeWeight(0.5);
            
            let innerSize = size - balustradeExtrusion;
            
            switch(balustradeMode) {
                case 'solid':
                    // Solid balustrade
                    for (let i = 0; i < 6; i++) {
                        let angle1 = (TWO_PI / 6) * i;
                        let angle2 = (TWO_PI / 6) * (i + 1);
                        
                        let x1 = cos(angle1) * innerSize;
                        let z1 = sin(angle1) * innerSize;
                        let x2 = cos(angle2) * innerSize;
                        let z2 = sin(angle2) * innerSize;
                        
                        beginShape();
                        vertex(x1, 0, z1);
                        vertex(x2, 0, z2);
                        vertex(x2, -spacing * 0.7, z2);
                        vertex(x1, -spacing * 0.7, z1);
                        endShape(CLOSE);
                    }
                    break;
                    
                case 'posts':
                    // Posts balustrade
                    for (let i = 0; i < 18; i++) {
                        let angle = (TWO_PI / 18) * i;
                        let x = cos(angle) * innerSize;
                        let z = sin(angle) * innerSize;
                        
                        push();
                        translate(x, -spacing * 0.35, z);
                        box(2, spacing * 0.7, 2);
                        pop();
                    }
                    break;
                    
                case 'diagonal':
                    // Diagonal pattern
                    for (let i = 0; i < 6; i++) {
                        let angle1 = (TWO_PI / 6) * i;
                        let angle2 = (TWO_PI / 6) * (i + 1);
                        
                        let x1 = cos(angle1) * innerSize;
                        let z1 = sin(angle1) * innerSize;
                        let x2 = cos(angle2) * innerSize;
                        let z2 = sin(angle2) * innerSize;
                        
                        // Diagonal lines
                        line(x1, 0, z1, x2, -spacing * 0.7, z2);
                        line(x2, 0, z2, x1, -spacing * 0.7, z1);
                    }
                    break;
                    
                case 'mesh':
                    // Mesh pattern
                    for (let i = 0; i < 6; i++) {
                        let angle1 = (TWO_PI / 6) * i;
                        let angle2 = (TWO_PI / 6) * (i + 1);
                        
                        for (let j = 0; j < 5; j++) {
                            let t = j / 4;
                            let x = lerp(cos(angle1), cos(angle2), t) * innerSize;
                            let z = lerp(sin(angle1), sin(angle2), t) * innerSize;
                            line(x, 0, z, x, -spacing * 0.7, z);
                        }
                    }
                    break;
            }
            
            pop();
        }

        function windowResized() {
            resizeCanvas(windowWidth, windowHeight);
        }
    </script>
</body>
</html>