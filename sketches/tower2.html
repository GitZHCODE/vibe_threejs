<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Twisting Towers</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
  <style>
    body { margin: 0; overflow: hidden; background: #111; color: #fff; font-family: sans-serif; }
    #gui { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(0,0,0,0.5); padding: 10px; border-radius: 8px; max-width: 260px; }
    #gui p { margin: 4px 0 2px; font-size: 14px; }
    #gui input, #gui select { margin-bottom: 6px; display: block; width: 100%; }
  </style>
</head>
<body>
  <div id="gui"></div>
  <script>
    let floorCountSlider, floorSpacingSlider, twistSlider;
    let separationSlider, radiusSlider;
    let wireframeCheckbox, slabColorPicker;
    let solverSelector, decaySlider, minScaleSlider, attractorPosSlider;

    function setup() {
      createCanvas(windowWidth, windowHeight, WEBGL);
      const gui = document.getElementById('gui');
      gui.innerHTML = `
        <p>Floor Count</p>
        <input id="floorCount" type="range" min="5" max="100" value="30">
        <p>Z-Spacing</p>
        <input id="floorSpacing" type="range" min="5" max="50" value="20">
        <p>Twist per Floor (Â°)</p>
        <input id="twist" type="range" min="0" max="10" value="2">
        <p>Separation Distance</p>
        <input id="separation" type="range" min="50" max="1000" value="500">
        <p>Polygon Radius</p>
        <input id="radius" type="range" min="20" max="200" value="100">
        <p>Slab Color</p>
        <input id="slabColor" type="color" value="#888888">
        <p>Wireframe Mode <input id="wireframe" type="checkbox"></p>
        <hr style="border:1px solid #444; margin:8px 0;">
        <p>Attractor Position</p>
        <input id="attractorPos" type="range" min="0" max="1" step="0.01" value="0">
        <p>Scaling Solver</p>
        <select id="solver">
          <option value="none">None</option>
          <option value="linear">Linear</option>
          <option value="exponential">Exponential</option>
          <option value="inverse">Inverse</option>
          <option value="sine">Sine</option>
          <option value="cosine">Cosine</option>
          <option value="smoothstep">Smoothstep</option>
        </select>
        <p>Decay</p>
        <input id="decay" type="range" min="0" max="5" step="0.01" value="0.1">
        <p>Minimum Scale</p>
        <input id="minScale" type="range" min="0" max="2" step="0.01" value="0.2">
      `;

      floorCountSlider   = select('#floorCount');
      floorSpacingSlider = select('#floorSpacing');
      twistSlider        = select('#twist');
      separationSlider   = select('#separation');
      radiusSlider       = select('#radius');
      slabColorPicker    = select('#slabColor');
      wireframeCheckbox  = select('#wireframe');
      solverSelector     = select('#solver');
      decaySlider        = select('#decay');
      minScaleSlider     = select('#minScale');
      attractorPosSlider = select('#attractorPos');

      noStroke();
    }

    function draw() {
      background(30);
      orbitControl();

      const nFloors   = +floorCountSlider.value();
      const spacing   = +floorSpacingSlider.value();
      const twistDeg  = +twistSlider.value();
      const sep       = +separationSlider.value();
      const r         = +radiusSlider.value();
      const slabColor = color(slabColorPicker.value());
      const solver    = solverSelector.value();
      const decay     = +decaySlider.value();
      const minScale  = +minScaleSlider.value();
      const attractor = +attractorPosSlider.value();

      for (let t = -1; t <= 1; t += 2) {
        push();
        translate(t * sep / 2, 0, 0);
        for (let i = 0; i < nFloors; i++) {
          const norm = i / (nFloors - 1);
          const y    = map(i, 0, nFloors - 1,
                        -((nFloors - 1) * spacing) / 2,
                         ((nFloors - 1) * spacing) / 2);
          push();
          translate(0, y, 0);

          // progressive twist: (i+1) * twistDeg
          rotateY(radians((i + 1) * twistDeg));

          // scale via attractor
          const distNorm = abs(norm - attractor);
          const scl      = computeScale(distNorm, solver, decay, minScale);
          scale(scl);

          // render
          strokeWeight(1);
          if (wireframeCheckbox.elt.checked) {
            noFill(); stroke(slabColor);
          } else {
            fill(slabColor); stroke(0);
          }
          drawPolygonXZ(r, 8);
          pop();
        }
        pop();
      }
    }

    // scaling computation
    function computeScale(t, solver, decay, minScale) {
      let s = 1;
      switch (solver) {
        case 'linear':     s = 1 - decay * t; break;
        case 'exponential': s = exp(-decay * t); break;
        case 'inverse':     s = 1 / (1 + decay * t); break;
        case 'sine':        s = sin((1 - t) * HALF_PI); break;
        case 'cosine':      s = cos(t * HALF_PI); break;
        case 'smoothstep':  s = t * t * (3 - 2 * t); break;
      }
      return constrain(s, minScale, 1);
    }

    // draw N-sided polygon in XZ plane
    function drawPolygonXZ(r, sides) {
      beginShape();
      for (let j = 0; j < sides; j++) {
        const ang = TWO_PI * j / sides;
        vertex(cos(ang) * r, 0, sin(ang) * r);
      }
      endShape(CLOSE);
    }

    function windowResized() {
      resizeCanvas(windowWidth, windowHeight);
    }
  </script>
</body>
</html>






